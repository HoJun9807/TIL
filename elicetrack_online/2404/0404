## elice cloudtrack - [3기-spring-study] ##

# Java/Spring
    다형성의 본질
        인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
        클라이언트를 변경하지 않고, 서버의 구현 기능(Repo)을 유연하게 변경할 수 있다.

    역할과 구현의 분리
        인터페이스를 안정적으로 잘 설계하는 것이 중요
            => 역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두 큰 변경을 발생해야한다.
        스프링을 사용하면 레고 블럭을 조립하듯이 구현을 편리하게 변경할 수 있다.

    SOLID
        SRP : 단일 책임 원칙 
            => 중요한 기준을 변경, 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
        OCP : 개방-폐쇄 원칙
            => 다형성 / 확장(객체 변경)에는 열려 있으나 변경(기존 코드)에는 닫혀 있다.
                !문제점 : 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
                        다형성을 사용했지만 OCP원칙을 지킬 수 없다.
                해결방안 : 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다 <= Spring의 지원
        LSP : 리스코프 치환 원칙
            => 단순히 컴파일의 성공하는 것이 아닌 성능에 대한 인터페이스 규약을 지켜야 한다.
                ex. 자동차의 엑셀은 앞으로 가는 것 -> 뒤로 가게 만들면 LSP를 위반한 것이다. 느리더라도 앞으로 가게 해야함.
        ISP : 인터페이스 분리 원칙
            => 특정 클라이언트를 위한 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다.
                기능 변경 시 관련된 코드의 변경점이 적어지기 때문에
        DIP : 의존관계 역전 원칙
            => 역할(배역)과 구현체(배우)를 철저하게 분리하여 구현체는 대체가 가능하게 역할에만 의존하게 해야 한다.
            => 클라이언트가 인터페이스에 의존해야 한다.
            => 멤버 서비스는 멤버 리포지토리 인터페이스에만 의존하도록 설계를 해야한다.
                !구현체에 의존하게 되면 변경이 어렵다. <= Spring의 지원

        객체 지향의 핵심은 다향성 하지만 다형성만으로는 OCP, DIP를 지킬 수 없다.    

    스프링은 DI와 DI 컨테이너 제공으로 OCP, DIP를 가능하게 지원해줌 => 클라이언트 코드 변화없이 설계 가능

    AppConfig 
        애플리케이션의 전체 동작 방식을 구현하기 위해, 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스
        구현 클래스를 선택하여 애플리케이션이 어떻게 동작해야 할 지 전체 구성을 책임진다.
        역할과 구현 클래스가 한눈에 들어온다. 애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악할 수 있다.

    IoC 제어의 역전
        AppConfig 생성 이후 구현체는 자신의 로직을 실행하는 역할만 담당하고, AppConfig가 관리,제어한다.

    프레임워크 vs 라이브러리
        프레임워크는 내가 작송한 코드를 제어하고, 대신 실행해주는 것
        라이브러리는 내가 작성한 코드가 직접 제어의 흐름을 담당하는 것

    DI(의존관계 주입)
        인터페이스에 의존하면 실제 어떤 구현 객체가 사용되는지 알 수 없다.

        의존 관계는 정적인 클래스 의존관계(import)와, 실행 시점에서 결정되는 동적인 객체 의존 관계가 있다
        !하지만 해당 인터페이스에는 어떤 객체가 주입되는지는 알 수 없다. 이것은 <동적인 객체 인스턴스 의존 관계>라고 한다.
            실행 시점에 외부(AppConfig)에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존 관계가 연결되는 것을 의존관계 주입이라 한다.
        의존 관계 주입을 사용하면 정적인 클래스 의존관계는 변경하지 않고, 동적인 객체 인스턴스 의존 관계를 쉽게 변경할 수 있다.

    DI(IoC) 컨테이너
        AppConfig처럼 객체를 생성하고 관리하면서 의존관꼐를 연결해 주는 것을 말한다.

    스프링 컨테이너
        ApplicationContext를 스프링 컨테이너라고 한다. ApplicationContext의 객체를 생성을 선언하여 AppConfig.class를 파라미터로한 인스턴트를 생성한다.
        기존에는 AppConfig를 사용해서 직접 객체를 생성(new)하였지만, 이제부터는 스프링 컨테이너를 통해 사용한다.
        applicationContext.getBean() 사용하여 스프링 빈을 찾아낸다.

    스프링 컨테이너와 스프링 빈
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
        ApplicationContext는 인터페이스이다.
        빈의 이름은 메서드 이름으로 사용한다,

        스프링 컨테이너에서 스프링 빈을 찾는 가장 기본적인 조회 방법 
        ac.getBean(빈이름, 타입) / ac.getBean(타입)
        조회 대상 스프링 빈이 없으면 예외 발생
        NoSuchBeanDefinitionException : No bean named 'xxxxx' available

    BeanFactory
        스프링 컨테이너의 최상위 인터페이스
        스프링 빈을 관리하고 조회하는 역할
        getBean()을 제공

    ApplicationContext
        BeanFactory 기능을 모두 상속 받아서 제공한다.
        + 부가 기능

    웹 애플리케이션과 싱글톤
        스프링은 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다는 것을 알아야한다.
        스프링 애플리케이션은 웹 / 앱 개발이 가능하다.
        웹 애플리케이션은 보통 여러 고객이 동시에 요청한다.

        
