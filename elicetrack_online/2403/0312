## elice cloudtrack - [3기-02-02-01] ##

# 다형성
    - 하나의 이름을 가진 변수, 함수, 클래스가 다양한 의미로 해석 될 수 있도록 구현하는 것
    
    - 구현 방법
        1. Overloading : 동일한 이름의 메서드를 여러 개 정의
        2. Overriding : 부모 클래스의 메서드를 재정의
        3. 상속의 계층관계 활용
            - 자식 클래스가 부모 클래스의 타입으로도 해석 될 수 있다.

# abstract
    - 기타 제어자
    - 자식 클래스가 공톡적으로 가져야 하지만, 부모 클래스에서 내용이 작성될 필요가 없다면 => 빈 메서드로 선언하거나, 추상 메서드를 선언한다.
    - 접근 제어자 앞에 선언

    - 추상 메서드 :
        - 부모 클래스에 내용 작성 없이 정의만 하고 자식 클래스에서 내용을 작성하는 메서드
        - 구현부{ }를 가질 수 없다.

# static
    - 기타 제어자
    - 객체가 아닌 클래스 멤버 변수
    - static 메서드 내부에서는 static 멤버 변수만 사용 가능
    - 모든 객체에서 동일한 값
    - 인스턴스를 생성하지 않아도 static 메서드를 사용할 수 있다.
    - 클래스에 선언 불가

# final
    - 클래스 선언에 사용 가능 / 상속 불가능

# 제어자 조합
    - 접근 제어자 : public / protected / (default) / private
    - 기타 제어자 : abstract / static / final

    - 클래스 : public / (default) / final / abstract
        - inner Class 인 경우 protected / private도 사용 가능

    - 메서드 : 모든 제어자

    - 멤버변수 : public / protected / (default) / private / static / final

    - 일반 변수 : final

    - 조합할 수 없는 경우
        - 접근 제어자를 동시에 여러 개 사용 할 수 없다.

        - abstract 
            final 클래스명 : 상속이 불가능
            final 멤버 변수 : Overriding 불가
            static 멤버 변수 : 클래스 멤버이므로 상속 불가
            pricate 멤버 변수 : Overriding 불가
            => 메서드는 무조건 상속 / Overriding이 되어야 한다.

        - 클래스 선언 시 prtected, private를 사용하지 못하는 이유는?
            => 패키지는 부모-자식 관계를 가지지 않기 때문에

# 초기화 블록
    - 변수를 초기화하는 새로운 방법
        - 인스턴스 초기화 블럭 : 인스턴스 생성시에 생성자보다 먼저 실행
            멤버 변수 초기화에 활용되며, 중괄호를 이용하여 작성

        - 클래스 초기화 블럭 : statac 키워드와 함께 작성되며 메모리가 추가되는 시점에서 한 번만 실행된다.

# Inner Class
    - (외부)클래스안에 (내부)클래스를 작성하는 것
        인스턴스 내부 클래스 :
        - 멤버 변수,메서드와 같이 인스턴스에 포함되는 클래스(같은 위치)
        - 외부 클래스의 멤버와 접근 가능

        정적 내부 클래스 :
        - static 키워드를 통해 선언하고, static 멤버만 접근이 가능하다.

        지역 내부 클래스 :
        - 메서드 내부 / 초기화 블록 내부에서 선언
        - 해당 블록에서만 사용 가능
        
        익명 내부 클래스 :
        - 이름 없이 생성되는 클래스
        - 한번만 사용할 때 선언되며 인스턴스 생성을 동시에 진행
        - 추상 메서드나 클래스를 구현하거나 상속하여 사용
        - 인터페이스 구현에 사용

    - why use? :
        - 훨씬 간결하고 가독성 있게 코드를 작성할 수 있고, 관계를 명확하게 볼 수 있기 때문에
        - 콜백 / 이벤트 처리 등의 구현을 위해 활용

        
