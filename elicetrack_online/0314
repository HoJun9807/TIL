## elice cloudtrack - [3기-02-04-01] ##

# Interface
        - 사용하는 메서드를 상속 받도록 설계하는 것은 비효율적인 코드
        - 동작 메서드를 작성해 놓고, 구현을 강제하도록 하는 명세서
        - 여러 클래스에서 공통적으로 행하는 동작을 정의하고 싶을 때 사용
        - 인스턴스 객체 참조 변수로도 사용

        - 작성 방법
            - interface 키워드 사용 / public, (default) 접근 제어자
            - 구현 내용이 작성되지 않은 형태로 구현
                => 인터페이스를 구현하는 클래스는 해당 메서드를 모두 구현
            - 인터페이스 내의 모든 메서드는 작성하지 않아도 public abstract제어자로 선언된다
            - 구현 시 implements 키워드를 사용

        - 특성
            1. 클래스 상속과 동시에 구현 가능
            2. 다중 구현
            3. 인터페이스 상속 => extends 사용
            4. 인터페이스 상수 정의

        VS abstract
            - 추상 클래스이기 때문에 일반 멤버 변수 선언 가능
            - 추상 클래스는 구현이 포함된 일반 메서드도 작성 가능
            
            - 인터페이스는 public static final 제어자를 가진 상수만 선언
            - 인터페이스는 메서더의 구현이 불가능

        - 클래스에서 다중 상속이 불가능한 이유?
            => 두 클래스이상에서 동일한 멤버를 가지고 있다면, 어떤 멤버의 구현 내용을 상속 받아야 하는지 모호 해지기 때문

            - 인터페이스 에서는 구현부가 존재하지 않기 때문에 클래스에서 발생하는 모호성이 존재하지 않음

        - defalt Method : 
            defalt 키워드를 사용하면 인터페이스 내에서 직접 구현 가능
        - static Method :
            클래스와 동일한 static 메서드를 추가할 수 있다. 

# 패키지
    - 비슷한 성격의 클래스들을 모아 놓은 것
    - 같은 폴더 내에 있으면 동일한 패키지에 포함
    - 패키지 내에 서브 패키지도 존재
    - 코드의 가독성/ 유지보수성 상승 및 클래스의 용도를 명확하게 하기 위해

# OOP 디자인 패턴
    - 반복적으로 발생하는 문재를 해결하기 위해 재사용 가능한 패턴으로 정의해 놓은 솔루션 => 효율적으로 코드 설계를 위해 정해진 패턴

    -GoF 디자인 패턴
        생성 / 구조 / 행위 패턴으로 나눌 수 있다.
        
        싱글턴 패턴의 기본 구조
            - 생성자를 private로 외부로 부터 차단
            - private static 제어자를 가진 instance 멤버 변수에 저장한다. ex. private static 생성자 instance
            - 인스턴스 생성은 getInstace() 메서드에서만 진행한다.
                null일 때의 조건을 작성해 줘야한다.

