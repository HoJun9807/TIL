## elice cloudtrack - 0318 ##

# Generic
    - 컬렉션, 람다식, 스트림, NIO에서 널리 사용된다.
    - 제네릭을 모르면 도큐먼트를 해석할 수 없다.
    - 이점 : 
        - 컴파일시 강한 타입 체크를 할 수 있다.
        - 타입 변환을 제거할 수 있다. <>안에 타입을 미리 강하게 명시하기
        때문에 
    
    - 제네릭 타입이란? :
        - 타입을 파라미터로 가지는 클래스와 인터페이스
            클래스 또는 인터페이스 이름 뒤에 <> 부호
        - 타입 파라미터
            일반적으로 대문자 알파벳 한문자로 표현
            구체적인 타입을 지정

        - 비제네릭 => Object타입을 사용하므로서 빈번한 타입 변환이 발생
                        -> 성능 저하
        - 제네릭 => 원하는 타입을 인스턴스 생성 시 구체적으로 선언해주기
        때문에 구체적인 클래스가 된다.

    - 멀티 타입 파라미터 :
        - 두 개 이상의 타입을 파라미터를 사용해서 선언할 수 있다.
            ex. class ex<T,M>{}

    - 제네릭 메소드 :
        선언 방법 : 리턴 타입 앞에 <T> 작성한다.
        리턴 타입과 매개변수에 사용한다.

        호출 방법
            ex. Box<Integer> box = boxing(100);

    - 제한된 타입 파라미터 : <T extends 상위타입>
        - 상속 및 구현 관계를 이용해서 타입을 제한
            타입 파라미터 경우 인터페이스를 상속해도 extends로 작성
        - 주의할 점 :
            - {}타입 파라미터 변수로 사용 가능한 것은 상위 타입의 멤버로
            제한된다.

    - 와일드카드 타입 :
        - 제네릭 타입을매개변수나 리턴타입으로 사용할 때 타입 파라미터를 제한

        - 타입 종류
            1. <?> : 제한없음
            2. <? extends 상위타입> : 상위 클래스
            3. <? super 하위타입> : 하위 클래스

    - 제네릭 타입의 상속과 구현 :
        - 제네릭 타입을 부모 클래스로 사용
            - 타입 파라미터는 자식 클래스에도 작성해야 한다.
                ex. public class aclass<T,M> extends A<T,M>{}
            - 추가적인 타입 파라미터를 가질 수 있다.
                ex. public class aclass<T,M,C> extends A<T,M>{}

        - 제네릭 인터페이스를 구현할 경우
            - 타입 파라미터는 구현 클래스에도 작성해야 한다.
                ex. public class AImpl<T> implemnets A<T>{}
        

    # 
