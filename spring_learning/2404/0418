## spring_learning - JPA 0415 ##

# ORM
    ORM(Object-relational mapping)
        객체와 관계형 데이터베이스를 매핑한다는 뜻
        단순히 SQL을 개발자 대신에 작성하여 데이터베이스에 넘겨주는 것이 아닌 다양한 패러다임 불일치 문제까지 해결해준다.
        개발자는 어떻게 둘을 매핑해야하는지 매핑 방법만 ORM에게 알려주면 된다.

    JPA
        자바 ORM에 대한 API 표준 명세

    Hibernate
        가장 많이 사용되는 JPA 표준 인터페이스

    Why JPA?
        생산성 : 자바 컬렉션에 객체를 저장하듯이 JPA에 저장할 객체를 전달하기만 하면 된다.
        유지보수 : JDBC API 코드는 엔티티 필드를 하나만 추가해도 모두 변경해줘야 하지만 이러한 과정을 JPA가 대신해주기 때문에 유지보수 해야하는 코드가 줄어는다.
        패러다임의 불일치 해결

    엔티티 매니저 설정
        엔티티 매니저 팩토리 생성
            JPA 시작 시 persistence.xml 설정 정보를 사용하여 엔티티 매니저 팩토리를 생성해서 JPA를 사용할 수 있게 준비 한다.
            생성 비용이 크기 때문에 하나를 생성하여 전체를 앱에서 공유하도록 설정되어 있다.
        엔티티 매니저 생성
            팩토리에서 엔티티 매니저를 생성 / JPA의 기능 대부분은 엔티티 매니저에서 제공
        종료
            사용이 끝난 엔티티 매니저/팩토리는 반드시 종료해줘야 한다.

    트랜잭션 관리
        JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다. => 예외 발생 시 예외 처리 때문에

    비즈니스 로직 
        생성한 엔티티를 엔티티 매니저에 등록하여 DB에 등록,수정,삭제,조회를 한다.

    영속성 컨텍스트
        엔티티를 영구 저장하는 환경
            em.persist(member); member엔티티를 저장한다고 표현하였지만, 엔티티 매니저를 사용하여 회원 엔티티를 영속성 컨텍스트에 저장한다는 뜻이다.
        엔티티 생명주기
            비영속성 : 영속성 컨텍스트와 전형 관계가 없는 상태
            영속 : 영속성 컨텍스트에 저장된 상태
            준영속 : 저장되었다가 분리된 상태
            삭제 : 삭제된 상태

        특징 :
            1. 영속성 컨텍스트와 식별자 값
                @Id 엔티티 식별자 값으로 구분한다. / 영속 상태는 식별자 값이 반드시 있어야함.
            2. 영속성 컨텍스트와 데이터베이스 저장
                트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영한다 .
                => 플러시(flush)
            3. 장점 : 1차 캐시 / 동일성 보장 / 쓰기 지연 / 변경 감지 / 지연 로딩

        엔티티 조회
            영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다.
            영속 상태의 엔티티는 모두 이곳에 저장되며 @Id로 매핑한 식별자이며 값은 엔티티 인스턴스이다.
            1차 캐시에 회원 엔티티를 저장하여도 아직 회원 엔티티는 DB에 저장되지는 않는다.
            식별자 값은 DB 기본키와 매핑되어 있어 저장 및 조회하는 기준은 DB의 기본 키 값이다.
            1차 캐시에 있는 같은 엔티티 인스턴스는 동일성을 갖는다.

        엔티티 등록
            엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 엔티티를 모아 둔다
                => 쓰기 지연
            트랜잭션은 하나의 단위로 내부 로직이 성공 시 commit이 되어 DB에 저장되지만, 내부 로직이 하나라도 실패 시 rollback된다.

        엔티티 수정
            SQL 수정 쿼리의 문제점
                기능이 추가되어 수정 쿼리를 추가로 작성한다는 것은 문제점이 많은 개발 방식이다.
                    => 비즈니스 로직이 직접/간접적으로 SQL에 의존하게 된다.
            JPA 변경 감지
                JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 스냅샷으로 복사하여 최소의 상태를 저장두고 플리시 시점에 스냅샷과 엔티티를 비교하여 변경된 엔티티를 찾는다.
                    => 데이터가 commit되기 전에 DB에 변경사항을 감지하여 미리 SQL을 데이터로 보낸 후 DB 트랜잭션을 커밋할 수 있다 / 데이터 전송량이 증가한다는 단점도 있다.
        
        엔티티 삭제
            em.remove() 삭제 대상 엔티티를 넘겨주면 엔티티를 삭제한다. 동일하게 SQL 저장소에 등록하고 트랜잭션을 커밋하여 플러시를 호출하여야 실제 DB에서 삭제 쿼리를 전달한다.

        플러시 : 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.
            1. 변경 감지가 동작하여 스냅샷과 비교하여 수정된 엔티티를 찾아 수정 쿼리를 SQL 저장소에 등록
            2. SQL 저장소의 쿼리를 데이터베이스에 전송
                호출 방법 : em.flush() 직접 호출 / 트랜잭션 커밋/ JPQL 쿼리 실행 시 자동 호출

            모드 옵션
                .AUTO : 커밋이나 쿼리를 실행할 때 플러시(기본값)
                .COMMIT : 커밋할 때만 플러시

        준영속 : 엔티티가 영속성 컨텍스트에서 분리된 상태
            => 해당 상태는 DB에 반영되지 않는다.
            병합 : 준영속 상태의 엔티티를 다시 영속 상태로 변경하기 위한 메소드 merge() / save or update기능을 수행
            